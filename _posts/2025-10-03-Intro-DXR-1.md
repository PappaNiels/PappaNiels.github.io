---
layout: post
title:  "Intro to DirectX Raytracing: The concepts (part 1)"
date:   2025-10-03 09:00:13 +0100
categories: posts
permalink: /posts/intro-dxr/part-1
---

Computer graphics is evolving rapidly. More techniques are applied, optimizations are created and we got more computational power as ever before. Everything to make the final image look as realistic as possible (or not). In 2018, Nvidia announced their new graphics card with 'special' RT cores. This meant, that shipping games with ray traced and more realistic graphics was possible, all while it was smooth and enough for gamers to enjoy those beautiful graphics.

The following articles will show my interpretation on what DXR is and how it works. After reading these articles, you would be able to create a ray tracer using DXR, and you are able to expand it with new ray tracing concepts or resources. In a later article I will also show you how you can use inline

<figure>
    <img src="../../assets/dxr/part-1/voxel-example.jpg"
         alt="Ray traced voxels"
         height=388
         width=680>
    <figcaption><i>Ray traced voxels using a CPU ray tracer.</i></figcaption>
</figure>

***

# Table of content
- [Basics](part-1.html#Basics)
- [The DirectX Raytracing API](part-1.html#DirectX-Raytracing)
    - Test
    - Test1
- [References](part-1.html#References)

<span id="Basics">
# Basics

But what is ray tracing exactly? Lets start with the basics and the most scary part for a lot of people. **Math!**. Do not worry. I will try to make it as simple as possible, so a train monkey can trace rays using the math examples I will provide.

Ray tracing mainly consists of vector math. A vector consists of multiple numbers representing either a position or a direction within a coordinate system. For our case, we will have a vector of three numbers for our 3D world. Mathematicians would note a 3D vector as the following:

$$\begin{pmatrix}
x \\ y \\ z
\end{pmatrix}$$

A ray consists of at least two vectors. One is for the direction the ray goes, and one for the origin. As last, a ray has a number (or lambda) that is used as the distance the ray has traveled. 

$$x = \vec{O} + \vec{D} * t$$

> Note:
> The direction of the ray needs to be normalized (magnitude needs to be 1.0) to be to make sure we do not go through and skip our geometry. We can do that by dividing the vector by the length of the vector. 

$$\vec{t}_n = \dfrac{\vec{t}}{||\vec{t}||}$$

<i>Normalizing a vector.</i>
<br>

Lets do a simple example. Lets say, we are at the coordinate (2.5, -1.0, 0.0) and we look towards (0.5, 0.5, 0.0). At a distance of 3.0, there is an object. If we use the before mentioned formula, we can calculate the location of that object.

$$x = \vec{O} + \vec{D} * t$$

$$ \begin{pmatrix} x \\ y \\ z \end{pmatrix} = \begin{pmatrix} 2.5 \\ -1.0 \\ 0.0 \end{pmatrix} + \begin{pmatrix} 0.5 \\ 0.5 \\ 0.0 \end{pmatrix} \times 3.0 $$

$$ = \begin{pmatrix} 2.5 \\ -1.0 \\ 0.0 \end{pmatrix} + \begin{pmatrix} 1.5 \\ 1.5 \\ 0.0 \end{pmatrix}$$

$$ = \begin{pmatrix} 4.0 \\ 0.5 \\ 0.0 \end{pmatrix} $$

Now we know where the object is in the world ((4.0, 0.5, 0.0) in this case) and we can do more calculations based on that position (e.g. lighting, shadows, reflections, ...). If we take that to C++ code it would look like this:

```cpp
struct Ray
{
    float3 Origin;      // O
    float3 Direction;   // D
    float  Distance;    // t
};

float3 GetWorldPosition(const Ray& ray)
{
    return ray.Origin + ray.Direction * ray.Distance;
}

``` 

If you want to know more about vectors, you can watch [this](https://www.youtube.com/watch?v=Ej3ZVxljJfo) YouTube video from FloatyMonkey to fully understand vector math.

$$\sum x$$
$$x_{2a+b}$$

<span id="DirectX-Raytracing">
# DirectX Raytracing: API


<span id="References">
# References

<span id="Ref-1">
[1] [RayTracingInOneWeekend](https://raytracing.github.io/books/RayTracingInOneWeekend.html)